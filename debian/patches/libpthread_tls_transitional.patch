Index: libpthread/pthread/pt-create.c
===================================================================
RCS file: /cvsroot/hurd/hurd/libpthread/pthread/pt-create.c,v
retrieving revision 1.4
diff -u -p -r1.4 pt-create.c
--- libpthread/pthread/pt-create.c	4 May 2005 16:04:06 -0000	1.4
+++ libpthread/pthread/pt-create.c	13 Jun 2007 03:42:13 -0000
@@ -127,6 +127,15 @@
   if (err)
     goto failed_thread_alloc;
 
+  if (_dl_allocate_tls) {
+    pthread->tcb = _dl_allocate_tls (NULL);
+    *pthread->tcb = pthread->tcb;
+    if (!pthread->tcb)
+      goto failed_thread_tls_alloc;
+  } else {
+    pthread->tcb = NULL;
+  }
+
   /* And initialize the rest of the machine context.  This may include
      additional machine- and system-specific initializations that
      prove convenient.  */
@@ -192,6 +201,9 @@
  failed_sigstate:
   __pthread_sigstate_destroy (pthread);
  failed_setup:
+  if (_dl_deallocate_tls && pthread->tcb)
+    _dl_deallocate_tls (pthread->tcb, 1);
+ failed_thread_tls_alloc:
   __pthread_thread_dealloc (pthread);
   __pthread_thread_halt (pthread, 0);
  failed_thread_alloc:
Index: libpthread/pthread/pt-exit.c
===================================================================
RCS file: /cvsroot/hurd/hurd/libpthread/pthread/pt-exit.c,v
retrieving revision 1.2
--- libpthread/pthread/pt-exit.c	4 May 2005 16:04:06 -0000	1.2
+++ libpthread/pthread/pt-exit.c	13 Jun 2007 03:42:13 -0000
@@ -70,6 +70,8 @@
   if (self->cancel_state == PTHREAD_CANCEL_ENABLE && self->cancel_pending)
     status = PTHREAD_CANCELED;
 
+  if (_dl_deallocate_tls && self->tcb)
+    _dl_deallocate_tls (self->tcb, 1);
   __pthread_thread_dealloc (self);
 
   switch (self->state)
Index: libpthread/pthread/pt-internal.h
===================================================================
RCS file: /cvsroot/hurd/hurd/libpthread/pthread/pt-internal.h,v
retrieving revision 1.4
--- libpthread/pthread/pt-internal.h	4 Mar 2007 00:05:21 -0000	1.4
+++ libpthread/pthread/pt-internal.h	13 Jun 2007 03:42:13 -0000
@@ -85,6 +85,8 @@
 
   PTHREAD_SYSDEP_MEMBERS
 
+  void **tcb;
+
   struct __pthread *next, **prevp;
 };
 
@@ -272,4 +274,19 @@
 /* Default condition attributes.  */
 const struct __pthread_condattr __pthread_default_condattr;
 
+
+#ifdef __i386__
+#define libc_internal_function __attribute__ ((regparm (3), stdcall))
+#else
+#error oups
+#define libc_internal_function
+#endif
+/* Dynamic linker TLS allocation.  */
+#pragma weak _dl_allocate_tls
+extern void *_dl_allocate_tls(void *) libc_internal_function;
+
+/* Dynamic linker TLS deallocation.  */
+#pragma weak _dl_deallocate_tls
+extern void _dl_deallocate_tls(void *, int) libc_internal_function;
+
 #endif /* pt-internal.h */
Index: libpthread/sysdeps/mach/hurd/pt-docancel.c
===================================================================
RCS file: /cvsroot/hurd/hurd/libpthread/sysdeps/mach/hurd/pt-docancel.c,v
retrieving revision 1.2
--- libpthread/sysdeps/mach/hurd/pt-docancel.c	18 Nov 2002 22:20:58 -0000	1.2
+++ libpthread/sysdeps/mach/hurd/pt-docancel.c	13 Jun 2007 03:42:13 -0000
@@ -52,8 +52,8 @@
       err = __thread_abort (p->kernel_thread);
       assert_perror (err);
 
-      err = __thread_set_pcsp (p->kernel_thread,
-			       1, (void *) call_exit, 0, 0);
+      err = __thread_set_pcsptp (p->kernel_thread,
+			       1, (void *) call_exit, 0, 0, 0, 0);
       assert_perror (err);
 
       err = __thread_resume (p->kernel_thread);
Index: libpthread/sysdeps/mach/hurd/pt-sysdep.h
===================================================================
RCS file: /cvsroot/hurd/hurd/libpthread/sysdeps/mach/hurd/pt-sysdep.h,v
retrieving revision 1.3
--- libpthread/sysdeps/mach/hurd/pt-sysdep.h	18 Jan 2005 10:08:52 -0000	1.3
+++ libpthread/sysdeps/mach/hurd/pt-sysdep.h	13 Jun 2007 03:42:13 -0000
@@ -59,11 +59,13 @@
   __vm_deallocate (__mach_task_self (), (vm_offset_t) stackaddr, stacksize);
 }
 
-/* Change thread THREAD's program counter to PC if SET_PC is true and
-   its stack pointer to SP if SET_IP is true.  */
-extern int __thread_set_pcsp (thread_t thread,
+/* Change thread THREAD's program counter to PC if SET_PC is true,
+   its stack pointer to SP if SET_IP is true, and its thread pointer
+   to TP if SET_TP is true.  */
+extern int __thread_set_pcsptp (thread_t thread,
 			      int set_pc, void *pc,
-			      int set_sp, void *sp);
+			      int set_sp, void *sp,
+			      int set_tp, void *tp);
 
 
 #endif /* pt-sysdep.h */
Index: libpthread/sysdeps/mach/hurd/i386/pt-machdep.c
===================================================================
RCS file: /cvsroot/hurd/hurd/libpthread/sysdeps/mach/hurd/i386/pt-machdep.c,v
retrieving revision 1.1
--- libpthread/sysdeps/mach/hurd/i386/pt-machdep.c	10 Oct 2002 23:05:05 -0000	1.1
+++ libpthread/sysdeps/mach/hurd/i386/pt-machdep.c	13 Jun 2007 03:42:13 -0000
@@ -21,12 +21,28 @@
 
 #include <mach.h>
 #include <mach/i386/thread_status.h>
+#include <mach/i386/mach_i386.h>
+#include <mach/mig_errors.h>
 #include <mach/thread_status.h>
 
+#define HURD_TLS_DESC_DECL(desc, tcb)					      \
+  struct descriptor desc =						      \
+    {				/* low word: */				      \
+      0xffff			/* limit 0..15 */			      \
+      | (((unsigned int) (tcb)) << 16) /* base 0..15 */			      \
+      ,				/* high word: */			      \
+      ((((unsigned int) (tcb)) >> 16) & 0xff) /* base 16..23 */		      \
+      | ((0x12 | 0x60 | 0x80) << 8) /* access = ACC_DATA_W|ACC_PL_U|ACC_P */  \
+      | (0xf << 16)		/* limit 16..19 */			      \
+      | ((4 | 8) << 20)		/* granularity = SZ_32|SZ_G */		      \
+      | (((unsigned int) (tcb)) & 0xff000000) /* base 24..31 */		      \
+    }
+
 int
-__thread_set_pcsp (thread_t thread,
+__thread_set_pcsptp (thread_t thread,
 		   int set_ip, void *ip,
-		   int set_sp, void *sp)
+		   int set_sp, void *sp,
+		   int set_tp, void *tp)
 {
   error_t err;
   struct i386_thread_state state;
@@ -34,7 +50,7 @@
 
   state_count = i386_THREAD_STATE_COUNT;
 
-  err = __thread_get_state (thread, i386_THREAD_STATE,
+  err = __thread_get_state (thread, i386_REGS_SEGS_STATE,
 			    (thread_state_t) &state, &state_count);
   if (err)
     return err;
@@ -43,8 +59,26 @@
     state.uesp = (unsigned int) sp;
   if (set_ip)
     state.eip = (unsigned int) ip;
+  if (set_tp) {
+    HURD_TLS_DESC_DECL(desc, tp);
+
+    /* Get the first available selector.  */
+    int sel = -1;
+    err = __i386_set_gdt (thread, &sel, desc);
+    if (err == MIG_BAD_ID)
+      {
+	/* Old kernel, use a per-thread LDT.  */
+	sel = 0x27;
+	err = __i386_set_ldt (thread, sel, &desc, 1);
+	if (err)
+	  return err;
+      }
+    else if (err)
+      return err;
+    state.gs = (unsigned int) sel;
+  }
 
-  err = __thread_set_state (thread, i386_THREAD_STATE,
+  err = __thread_set_state (thread, i386_REGS_SEGS_STATE,
 			    (thread_state_t) &state,
 			    i386_THREAD_STATE_COUNT);
   if (err)
Index: libpthread/sysdeps/mach/hurd/i386/pt-setup.c
===================================================================
RCS file: /cvsroot/hurd/hurd/libpthread/sysdeps/mach/hurd/i386/pt-setup.c,v
retrieving revision 1.4
--- libpthread/sysdeps/mach/hurd/i386/pt-setup.c	12 May 2005 20:55:37 -0000	1.4
+++ libpthread/sysdeps/mach/hurd/i386/pt-setup.c	13 Jun 2007 03:42:13 -0000
@@ -92,9 +92,10 @@
   ktid = __mach_thread_self ();
   if (thread->kernel_thread != ktid)
     {
-      err = __thread_set_pcsp (thread->kernel_thread,
+      err = __thread_set_pcsptp (thread->kernel_thread,
 			       1, thread->mcontext.pc,
-			       1, thread->mcontext.sp);
+			       1, thread->mcontext.sp,
+			       1, thread->tcb);
       assert_perror (err);
     }
   __mach_port_deallocate (__mach_task_self (), ktid);
