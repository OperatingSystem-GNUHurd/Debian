diff --git a/hurd/process.defs b/hurd/process.defs
index bf90556..8c17666 100644
--- a/hurd/process.defs
+++ b/hurd/process.defs
@@ -373,7 +373,11 @@ routine proc_getnports (
 
 /*** Routines related to early server bootstrapping ***/
 
-skip;  /* Reserved for proc_set_init_task */
+/* Set the task of process HURD_PID_INIT. Only the startup process
+   HURD_PID_STARTUP may use this interface.  */
+routine proc_set_init_task (
+       process: process_t;
+       task: task_t);
 
 /* Inform the process server that the process is important.  */
 routine proc_mark_important (
diff --git a/hurd/process_request.defs b/hurd/process_request.defs
index 38e7146..cb8f083 100644
--- a/hurd/process_request.defs
+++ b/hurd/process_request.defs
@@ -374,7 +374,10 @@ simpleroutine proc_getnports_request (
 
 /*** Routines related to early server bootstrapping ***/
 
-skip;  /* Reserved for proc_set_init_task */
+simpleroutine proc_set_init_task_request (
+       process: process_t;
+       ureplyport reply: reply_port_t;
+       task: task_t);
 
 /* Inform the process server that the process is important.  */
 simpleroutine proc_mark_important_request (
diff --git a/include/pids.h b/include/pids.h
index 22415f4..dff7635 100644
--- a/include/pids.h
+++ b/include/pids.h
@@ -22,8 +22,9 @@
 #ifndef _HURD_PROCESSES_H
 #define _HURD_PROCESSES_H
 
-#define HURD_PID_STARTUP	1
-#define HURD_PID_KERNEL		2
-#define HURD_PID_PROC		3
+#define HURD_PID_INIT		1
+#define HURD_PID_STARTUP	2
+#define HURD_PID_KERNEL		3
+#define HURD_PID_PROC		4
 
 #endif  /* _HURD_PROCESSES_H */
diff --git a/init/init.c b/init/init.c
index 94f1a9b..9982558 100644
--- a/init/init.c
+++ b/init/init.c
@@ -1057,7 +1057,7 @@ start_child (const char *prog, char **progargs)
 	       NULL, 0,	/* OSF Mach */
 #endif
 	       0, &child_task);
-  proc_child (procserver, child_task);
+  proc_set_init_task (procserver, child_task);
   proc_task2pid (procserver, child_task, &child_pid);
   proc_task2proc (procserver, child_task, &default_ports[INIT_PORT_PROC]);
 
diff --git a/proc/main.c b/proc/main.c
index 73abbc0..6fe2330 100644
--- a/proc/main.c
+++ b/proc/main.c
@@ -1,5 +1,5 @@
 /* Initialization of the proc server
-   Copyright (C) 1993,94,95,96,97,99,2000,01 Free Software Foundation, Inc.
+   Copyright (C) 1993,94,95,96,97,99,2000,01,13 Free Software Foundation, Inc.
 
 This file is part of the GNU Hurd.
 
@@ -82,7 +82,12 @@ main (int argc, char **argv, char **envp)
   generic_port = ports_get_right (genport);
 
   /* Create the initial proc object for init (PID 1).  */
-  startup_proc = create_startup_proc ();
+  init_proc = create_init_proc ();
+
+  /* Create the startup proc object for /hurd/init (PID 2).  */
+  startup_proc = allocate_proc (MACH_PORT_NULL);
+  startup_proc->p_deadmsg = 1;
+  complete_proc (startup_proc, HURD_PID_STARTUP);
 
   /* Create our own proc object.  */
   self_proc = allocate_proc (mach_task_self ());
diff --git a/proc/mgt.c b/proc/mgt.c
index d7ad296..6d3df7e 100644
--- a/proc/mgt.c
+++ b/proc/mgt.c
@@ -1,5 +1,6 @@
 /* Process management
-   Copyright (C) 1992,93,94,95,96,99,2000,01,02 Free Software Foundation, Inc.
+   Copyright (C) 1992,93,94,95,96,99,2000,01,02,13
+     Free Software Foundation, Inc.
 
 This file is part of the GNU Hurd.
 
@@ -184,7 +185,7 @@ S_proc_child (struct proc *parentp,
   /* Process hierarchy.  Remove from our current location
      and place us under our new parent.  Sanity check to make sure
      parent is currently init. */
-  assert (childp->p_parent == startup_proc);
+  assert (childp->p_parent == init_proc);
   if (childp->p_sib)
     childp->p_sib->p_prevsib = childp->p_prevsib;
   *childp->p_prevsib = childp->p_sib;
@@ -583,7 +584,7 @@ allocate_proc (task_t task)
 /* Allocate and initialize the proc structure for init (PID 1),
    the original parent of all other procs.  */
 struct proc *
-create_startup_proc (void)
+create_init_proc (void)
 {
   static const uid_t zero;
   struct proc *p;
@@ -592,7 +593,7 @@ create_startup_proc (void)
   p = allocate_proc (MACH_PORT_NULL);
   assert (p);
 
-  p->p_pid = HURD_PID_STARTUP;
+  p->p_pid = HURD_PID_INIT;
 
   p->p_parent = p;
   p->p_sib = 0;
@@ -640,7 +641,7 @@ proc_death_notify (struct proc *p)
 }
 
 /* Complete a new process that has been allocated but not entirely initialized.
-   This gets called for every process except startup_proc (PID 1).  */
+   This gets called for every process except init_proc (PID 1).  */
 void
 complete_proc (struct proc *p, pid_t pid)
 {
@@ -659,30 +660,47 @@ complete_proc (struct proc *p, pid_t pid)
 
   p->p_pid = pid;
 
-  ids_ref (&nullids);
-  p->p_id = &nullids;
+  if (pid == HURD_PID_STARTUP)
+    {
+      /* Equip HURD_PID_STARTUP with the same credentials as
+         HURD_PID_INIT.  */
+      static const uid_t zero;
+      p->p_id = make_ids (&zero, 1);
+      assert (p->p_id);
+    }
+  else
+    {
+      ids_ref (&nullids);
+      p->p_id = &nullids;
+    }
 
   p->p_login = nulllogin;
   p->p_login->l_refcnt++;
 
   /* Our parent is init for now.  */
-  p->p_parent = startup_proc;
+  p->p_parent = init_proc;
 
-  p->p_sib = startup_proc->p_ochild;
-  p->p_prevsib = &startup_proc->p_ochild;
+  p->p_sib = init_proc->p_ochild;
+  p->p_prevsib = &init_proc->p_ochild;
   if (p->p_sib)
     p->p_sib->p_prevsib = &p->p_sib;
-  startup_proc->p_ochild = p;
+  init_proc->p_ochild = p;
   p->p_loginleader = 0;
   p->p_ochild = 0;
   p->p_parentset = 0;
 
   p->p_noowner = 1;
 
-  p->p_pgrp = startup_proc->p_pgrp;
+  p->p_pgrp = init_proc->p_pgrp;
 
-  proc_death_notify (p);
-  add_proc_to_hash (p);
+  /* At this point, we do not know the task of the startup process,
+     defer registering death notifications and adding it to the hash
+     tables.  */
+  if (pid != HURD_PID_STARTUP)
+    {
+      proc_death_notify (p);
+      add_proc_to_hash (p);
+    }
   join_pgrp (p);
 }
 
@@ -744,7 +762,7 @@ process_has_exited (struct proc *p)
 	    nowait_msg_proc_newids (tp->p_msgport, tp->p_task,
 				    1, tp->p_pgrp->pg_pgid,
 				    !tp->p_pgrp->pg_orphcnt);
-	  tp->p_parent = startup_proc;
+	  tp->p_parent = init_proc;
 	  if (tp->p_dead)
 	    isdead = 1;
 	}
@@ -752,17 +770,17 @@ process_has_exited (struct proc *p)
 	nowait_msg_proc_newids (tp->p_msgport, tp->p_task,
 				1, tp->p_pgrp->pg_pgid,
 				!tp->p_pgrp->pg_orphcnt);
-      tp->p_parent = startup_proc;
+      tp->p_parent = init_proc;
 
       /* And now append the lists. */
-      tp->p_sib = startup_proc->p_ochild;
+      tp->p_sib = init_proc->p_ochild;
       if (tp->p_sib)
 	tp->p_sib->p_prevsib = &tp->p_sib;
-      startup_proc->p_ochild = p->p_ochild;
-      p->p_ochild->p_prevsib = &startup_proc->p_ochild;
+      init_proc->p_ochild = p->p_ochild;
+      p->p_ochild->p_prevsib = &init_proc->p_ochild;
 
       if (isdead)
-	alert_parent (startup_proc);
+	alert_parent (init_proc);
     }
 
   /* If an operation is in progress for this process, cause it
@@ -942,3 +960,21 @@ S_proc_get_code (struct proc *callerp,
 
   return 0;
 }
+
+/* Implement proc_set_init_task as described in <hurd/process.defs>.  */
+error_t
+S_proc_set_init_task(struct proc *callerp,
+		     task_t task)
+{
+  if (! callerp)
+    return EOPNOTSUPP;
+
+  if (callerp != startup_proc)
+    return EPERM;
+
+  init_proc->p_task = task;
+  proc_death_notify (init_proc);
+  add_proc_to_hash (init_proc);
+
+  return 0;
+}
diff --git a/proc/proc.h b/proc/proc.h
index 80f8397..b544b8d 100644
--- a/proc/proc.h
+++ b/proc/proc.h
@@ -1,5 +1,6 @@
 /* Process server definitions
-   Copyright (C) 1992,93,94,95,96,99,2000,01 Free Software Foundation, Inc.
+   Copyright (C) 1992,93,94,95,96,99,2000,01,13
+     Free Software Foundation, Inc.
 
 This file is part of the GNU Hurd.
 
@@ -134,7 +135,8 @@ struct exc
 
 mach_port_t authserver;
 struct proc *self_proc;		/* process HURD_PID_PROC (us) */
-struct proc *startup_proc;	/* process 1 (init) */
+struct proc *init_proc;		/* process 1 (sysvinit) */
+struct proc *startup_proc;	/* process 2 (hurd/init) */
 
 struct port_bucket *proc_bucket;
 struct port_class *proc_class;
@@ -195,7 +197,7 @@ void exc_clean (void *);
 struct proc *add_tasks (task_t);
 int pidfree (pid_t);
 
-struct proc *create_startup_proc (void);
+struct proc *create_init_proc (void);
 struct proc *allocate_proc (task_t);
 void proc_death_notify (struct proc *);
 void complete_proc (struct proc *, pid_t);
diff --git a/procfs/main.c b/procfs/main.c
index 54e9682..8727f86 100644
--- a/procfs/main.c
+++ b/procfs/main.c
@@ -42,7 +42,7 @@ uid_t opt_anon_owner;
 #define OPT_CLK_TCK    sysconf(_SC_CLK_TCK)
 #define OPT_STAT_MODE  0400
 #define OPT_FAKE_SELF  -1
-#define OPT_KERNEL_PID 2
+#define OPT_KERNEL_PID 3
 #define OPT_ANON_OWNER 0
 
 #define NODEV_KEY  -1 /* <= 0, so no short option. */
@@ -153,7 +153,7 @@ struct argp_option common_options[] = {
   { "kernel-process", 'k', "PID", 0,
       "Process identifier for the kernel, used to retreive its command "
       "line, as well as the global up and idle times. "
-      "(default: 2)" },
+      "(default: 3)" },
   { "compatible", 'c', NULL, 0,
       "Try to be compatible with the Linux procps utilities.  "
       "Currently equivalent to -h 100 -s 0444 -S 1." },
