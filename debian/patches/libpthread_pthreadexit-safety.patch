As documented in pthread_exit(), the joiner has to make sure the thread really
is dead before freeing its stack.

Index: libpthread/pthread/pt-detach.c
===================================================================
RCS file: /cvsroot/hurd/hurd/libpthread/pthread/pt-detach.c,v
retrieving revision 1.2
diff -u -p -r1.2 pt-detach.c
--- libpthread/pthread/pt-detach.c	4 May 2005 16:04:06 -0000	1.2
+++ libpthread/pthread/pt-detach.c	8 Jul 2008 23:25:07 -0000
@@ -58,6 +58,9 @@ pthread_detach (pthread_t thread)
 
       __pthread_mutex_unlock (&pthread->state_lock);
 
+      /* Make sure that the kernel thread is dead.  */
+      __thread_terminate (pthread->kernel_thread);
+
       assert (pthread->stack);
       __pthread_stack_dealloc (pthread->stackaddr, pthread->stacksize);
       pthread->stack = 0;
Index: libpthread/pthread/pt-join.c
===================================================================
RCS file: /cvsroot/hurd/hurd/libpthread/pthread/pt-join.c,v
retrieving revision 1.1
diff -u -p -r1.1 pt-join.c
--- libpthread/pthread/pt-join.c	10 Oct 2002 23:05:06 -0000	1.1
+++ libpthread/pthread/pt-join.c	8 Jul 2008 23:25:07 -0000
@@ -53,6 +53,9 @@ pthread_join (pthread_t thread, void **s
       if (status)
 	*status = pthread->status;
 
+      /* Make sure that the kernel thread is dead.  */
+      __thread_terminate (pthread->kernel_thread);
+
       /* Make sure nobody can reference it anymore, and mark it as
          terminated.  */
       assert (pthread->stack);
