--- libports/manage-multithread.c.orig	2005-08-10 13:38:18.000000000 +0200
+++ libports/manage-multithread.c	2005-08-10 13:34:30.000000000 +0200
@@ -23,6 +23,19 @@
 #include <assert.h>
 #include <cthreads.h>
 #include <mach/message.h>
+#include <unistd.h> 		/* For sleep() */
+
+#define LP_DEBUG	0
+
+#if LP_DEBUG
+#include <stdio.h>		/* For printf() */
+#endif
+
+#define THREAD_MAX	250	/* Maximum number of threads */
+#define THREAD_DELAY 	64	/* Number of threads created as needed
+                                   without delay */
+#define DELAY		2	/* Time to sleep() each delayed thread
+                                   (in seconds) */
 
 void
 ports_manage_port_operations_multithread (struct port_bucket *bucket,
@@ -43,6 +56,7 @@
     {
       int spawn = 0;
       int status;
+      int type = 0; 	/* 0 = standard, 1 = master, 2 = delayed */
       struct port_info *pi;
       struct rpc_info link;
       register mig_reply_header_t *outp = (mig_reply_header_t *) outheadp;
@@ -59,8 +73,11 @@
       spin_lock (&lock);
       assert (nreqthreads);
       nreqthreads--;
-      if (nreqthreads == 0)
-	spawn = 1;
+      if (nreqthreads == 0 && totalthreads <= THREAD_MAX) {
+      	spawn = 1;
+      	if (totalthreads >= THREAD_DELAY)
+      	  type = 2;
+      }
       spin_unlock (&lock);
 
       if (spawn)
@@ -69,7 +86,8 @@
 	  totalthreads++;
 	  nreqthreads++;
 	  spin_unlock (&lock);
-	  cthread_detach (cthread_fork ((cthread_fn_t) thread_function, 0));
+	  cthread_detach (cthread_fork ((cthread_fn_t) thread_function,
+	                                (any_t)(intptr_t) type));
 	}
       
       /* Fill in default response. */
@@ -117,15 +135,31 @@
     }
 
   int
-  thread_function (int master)
+  thread_function (int type)
     {
       int timeout;
       error_t err;
-
+      
+      if (type == 2) {
+#if LP_DEBUG
+        printf("libports: delayed thread number: %d || ", totalthreads);
+        fflush(stdout);
+#endif  
+        sleep(DELAY);	/* Take a little break */
+#if LP_DEBUG
+        printf("libports: delayed thread running (%d)\n", totalthreads);
+        fflush(stdout);
+#endif
+      }
+#if LP_DEBUG
+      else {
+        printf("libports: new thread without delay running\n");
+      }
+#endif
       if (hook)
 	(*hook) ();
 
-      if (master)
+      if (type == 1)
 	timeout = global_timeout;
       else
 	timeout = thread_timeout;
@@ -138,7 +172,7 @@
 				       timeout);
       while (err != MACH_RCV_TIMED_OUT);
 
-      if (master)
+      if (type == 1)
 	{
 	  spin_lock (&lock);
 	  if (totalthreads != 1)
